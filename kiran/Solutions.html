<html>
  <head>
    <title> Solutions </title>
    <style>
      .button {
  border: none;
  color: white;
  padding: 16px 32px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  transition-duration: 0.4s;
  cursor: pointer;
        float:right;
}

.button1 {
  background-color: white; 
  color: black; 
  border: 2px solid #4CAF50;
}

.button1:hover {
  background-color: #4CAF50;
  color: white;
}
    </style>
  </head>
  <body>
    <a href="https://www.jdoodle.com/c-online-compiler"><button class="button button1">Compiler</button></a>
    <h1> Spiral order for binary tree </h1>
    <p> #include <b><</b>stdbool.h<b>></b> <br>
#include <b><</b>stdio.h<b>></b> <br>
#include <b><</b>stdlib.h<b>></b> <br>
struct node { <br>
    int data; <br>
    struct node* left;<br> 
    struct node* right; <br>
}; <br>
void printGivenLevel(struct node* root, int level, int ltr); <br>
int height(struct node* node); <br>
struct node* newNode(int data); <br>
void printSpiral(struct node* root) { <br>
    int h = height(root); <br>
    int i; <br>
    bool ltr = false; <br>
    for (i = 1; i <= h; i++) { <br>
        printGivenLevel(root, i,ltr); <br>
        ltr = !ltr; <br>
    } <br>
} <br>
void printGivenLevel(struct node* root, int level, int ltr) { <br>
    if (root == NULL) <br>
        return; <br>
    if (level == 1) <br>
        printf("%d ", root->data); <br>
    else if (level > 1) { <br>
        if (ltr) { <br>
            printGivenLevel(root->right, level - 1, ltr); <br>
            printGivenLevel(root->left, level - 1, ltr); <br>
        } <br>
        else {<br> 
            printGivenLevel(root->left, level - 1, ltr); <br>
            printGivenLevel(root->right, level - 1, ltr); <br>
        } <br>
    } <br>
} <br>
int height(struct node* node) { <br>
    if (node == NULL) <br>
        return 0; <br>
    else { <br>
        int lheight = height(node->left); <br>
        int rheight = height(node->right); <br>
        if (lheight > rheight) <br>
            return (lheight + 1); <br>
        else<br>
            return (rheight + 1); <br>
    } <br>
} <br>
struct node* newNode(int data) { <br>
    struct node* node = (struct node*)<br> 
        malloc(sizeof(struct node)); <br>
    node->data = data; <br>
    node->left = NULL; <br>
    node->right = NULL; <br>
    return (node);<br>
}<br>
int main() { <br>
    struct node* root = newNode(111);<br> 
    root->left = newNode(2); <br>
    root->right = newNode(3); <br>
    root->left->left = newNode(7); <br>
    root->left->right = newNode(6); <br>
    root->right->left = newNode(5); <br>
    root->right->right = newNode(4); <br>
    root->left->left->left = newNode(11);<br>
    root->left->left->right = newNode(12);<br>
    root->left->right->left = newNode(13);<br>
    root->left->right->right = newNode(14);<br>
    root->right->left->left = newNode(15);<br>
    root->right->left->right = newNode(16);<br>
    root->right->right->left = newNode(17);<br>
    root->right->right->right = newNode(18);<br>
    /*<br>
    Spiral Order traversal of binary tree <br>
    */<br>
    printSpiral(root); <br>
    return 0; <br>
} 
      </p>
      
      
      
      <br><br><br><br><br>
      
      
      
      <h1>Given an 8 digit number without repetitions. We have to print all the possible combination of that number in the ascending order</h1>
      <p>
        #include <b><</b>stdio.h<b>></b><br>
int possible(int arr[], int n) {<br>
        int i;<br>
        for (i = n-1; i > 0; i--)<br>
                if (arr[i] > arr[i-1])<br>
                        return 1;<br>
        return 0;<br>
}<br>
void print(int arr[], int n) {<br>
        int i;<br>
        for (i = 0; i < n; i++)<br>
                printf("%d",arr[i]);<br>
        printf("\n");<br>
}<br>
void swap(int* a, int* b) {<br>
    int t = *a;<br>
    *a = *b;<br>
    *b = t;<br>
}<br>
int partition (int arr[], int low, int high) {<br>
    int pivot = arr[high];<br>
    int i = (low - 1);<br>
    int j;<br>
    for ( j = low; j <= high- 1; j++) {<br>
        if (arr[j] <= pivot) {<br>
            i++;<br>
            swap(&arr[i], &arr[j]);<br>
        }<br>
    }<br>
    swap(&arr[i + 1], &arr[high]);<br>
    return (i + 1);<br>
}<br>
void quickSort(int arr[], int low, int high) {<br>
    if (low < high) {<br>
        int pi = partition(arr, low, high);
<br>        quickSort(arr, low, pi - 1);
<br>        quickSort(arr, pi + 1, high);
 <br>   }
<br>}<br>
void nextNumber(int arr[], int n) {<br>
        int i, j;<br>
        int currentMin = 1000000;<br>
        int index;<br>
        int temp;<br>
        for ( i = n-1; i > 0; i--) {<br>
                if (arr[i] > arr[i-1])  {<br>
                        for ( j = i; j < n; j++) {<br>
                                if (arr[i-1] < arr[j] && currentMin > arr[j]) {<br>
                                        currentMin = arr[j];<br>
                                        index = j;<br>
                                }<br>
                        }<br>
                        temp = arr[i-1];<br>
                        arr[i-1] = arr[index];<br>
                        arr[index] = temp;<br>
                        quickSort(arr,i,n-1);<br>
                        break;<br>
                }<br>
        }<br>
        return;<br>
}<br>
int main() {<br>
        int num;<br>
        int tmp;<br>
        int len = 0;<br>
        int i;<br>
        scanf("%d",&num);<br>
        tmp = num;<br>
        while (tmp) {<br>
                tmp /= 10;<br>
                len++;<br>
        }<br>
        int arr[len];<br>
        for (i = len-1; i >= 0; i--) {<br>
                arr[i] = num%10;<br>
                num /= 10;<br>
        }<br>
        while(1) {<br>
                print(arr,len);<br>
                if(possible(arr,len))<br> 
                        nextNumber(arr,len);<br>
                else <br>
                        break;<br>
        }<br>
        return 0;<br>
}
        </p>
      </body>
      </head>
      </html>
